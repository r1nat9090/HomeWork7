# 1. Реализовать класс Matrix (матрица). Обеспечить перегрузку конструктора класса (метод __init__()),
# который должен принимать данные (список списков) для формирования матрицы.
# Подсказка: матрица — система некоторых математических величин, расположенных в виде прямоугольной схемы.
# Примеры матриц: 3 на 2, 3 на 3, 2 на 4.
#
# 31    32         3    5    32        3    5    8    3
# 37    43         2    4    6         8    3    7    1
# 51    86        -1   64   -8
# Следующий шаг — реализовать перегрузку метода __str__() для вывода матрицы в привычном виде.
# Далее реализовать перегрузку метода __add__() для реализации операции сложения двух объектов класса Matrix (двух матриц).
# Результатом сложения должна быть новая матрица.
# Подсказка: сложение элементов матриц выполнять поэлементно —
# первый элемент первой строки первой матрицы складываем с первым элементом первой строки второй матрицы и т.д.

# class Matrix:
#     def __init__(self, data):
#         self.d = data
#
#     def __str__(self):
#         matrix = []
#         for i in self.d:
#             matrix.append(' '.join([str(k) for k in i]))
#         return '\n'.join(matrix)
#
#     def __add__(self, other):
#         matrix = []
#         for i, row in enumerate(self.d):
#             new_list = list(map(lambda x, y: x + y, row, other.d[i]))
#             matrix.append(new_list)
#         return Matrix(matrix)
#
# a = [[31, 32, 33], [3, 5, 32]]
# b = [[37, 43, 49], [2, 4, 6]]
#
#
# matrix_1 = Matrix(a)
# matrix_2 = Matrix(b)
# matrix_summ = matrix_1 + matrix_2
#
# print(matrix_summ)

# 2. Реализовать проект расчёта суммарного расхода ткани на производство одежды. Основная сущность (класс) этого проекта —
# одежда, которая может иметь определённое название. К типам одежды в этом проекте относятся пальто и костюм.
# У этих типов одежды существуют параметры: размер (для пальто) и рост (для костюма). Это могут быть обычные числа: V и H, соответственно.
# Для определения расхода ткани по каждому типу одежды использовать формулы: для пальто (V/6.5 + 0.5), для костюма (2*H + 0.3).
# Проверить работу этих методов на реальных данных.
# Реализовать общий подсчет расхода ткани. Проверить на практике полученные на этом уроке знания:
# реализовать абстрактные классы для основных классов проекта, проверить на практике работу декоратора @property.

# from abc import ABC, abstractmethod
#
# class Wear(ABC):
#
#     def __init__(self, name):
#         self.n = name
#
#     @abstractmethod
#     def material_cons(self):
#         pass
#
# class Coat(Wear):
#     def __init__(self, name, size):
#         self.s = size
#         Wear.__init__(self, name)
#
#     @property
#     def material_cons(self):
#         return f'Расход материала на пальто составляет {self.s / 6.5 + 0.5} квадратных метра'
#
#
# class Suit(Wear):
#     def __init__(self, name, height):
#         self.h = height
#         Wear.__init__(self, name)
#
#     @property
#     def material_cons(self):
#         return f'Расход материала на костюм составляет {2 * self.h + 0.3} квадратных метра'
#
# coat_1 = Coat('Пальто', 48)
# suit_1 = Suit('Костюм', 1.7)
# print(coat_1.material_cons)
# print(suit_1.material_cons)

# 3. Реализовать программу работы с органическими клетками, состоящими из ячеек.
# Необходимо создать класс Клетка. В его конструкторе инициализировать параметр, соответствующий количеству ячеек клетки (целое число).
# В классе должны быть реализованы методы перегрузки арифметических операторов:
# сложение (__add__()), вычитание (__sub__()), умножение (__mul__()), деление (__truediv__()).
# Данные методы должны применяться только к клеткам и выполнять увеличение, уменьшение, умножение и целочисленное (с округлением до целого) деление клеток, соответственно.
# Сложение. Объединение двух клеток. При этом число ячеек общей клетки должно равняться сумме ячеек исходных двух клеток.
# Вычитание. Участвуют две клетки. Операцию необходимо выполнять только если разность количества ячеек двух клеток больше нуля, иначе выводить соответствующее сообщение.
# Умножение. Создаётся общая клетка из двух. Число ячеек общей клетки определяется как произведение количества ячеек этих двух клеток.
# Деление. Создаётся общая клетка из двух. Число ячеек общей клетки определяется как целочисленное деление количества ячеек этих двух клеток.
#
# В классе необходимо реализовать метод make_order(), принимающий экземпляр класса и количество ячеек в ряду. Данный метод позволяет организовать ячейки по рядам.
# Метод должен возвращать строку вида *****\n*****\n*****..., где количество ячеек между \n равно переданному аргументу. Если ячеек на формирование ряда не хватает, то в последний ряд записываются все оставшиеся.
# Например, количество ячеек клетки равняется 12, количество ячеек в ряду — 5. Тогда метод make_order() вернёт строку: *****\n*****\n**.
# Или, количество ячеек клетки равняется 15, количество ячеек в ряду — 5. Тогда метод make_order() вернёт строку: *****\n*****\n*****.
# Подсказка: подробный список операторов для перегрузки доступен по ссылке.

# class Cell(object):
#     def __init__(self, size):
#         self.s = size
#
#     def __add__(self, other):
#         return Cell(self.s + other.s)
#
#     def __sub__(self, other):
#         result = self.s - other.s
#         if result > 0:
#             return Cell(result)
#         else:
#             raise Exception(f'{self} должно быть больше {other}')
#
#     def __mul__(self, other):
#         return Cell(self.s * other.s)
#
#     def __truediv__(self, other):
#         return Cell(self.s // other.s)
#
#     def make_order(self, row_size):
#         rows = ['*' * row_size for i in range(self.s // row_size)]
#         tail = '*' * (self.s % row_size)
#         rows.append(tail)
#         return '\n'.join(rows)
#
#     def __str__(self):
#         return '*' * self.s
#
# Cell_1 = Cell(2)
# Cell_2 = Cell(6)
# Cell_add = Cell_1 + Cell_2
# try:
#     Cell_sub1 = Cell_1 - Cell_2
# except Exception as i:
#     Cell_sub1 = None
#     print(i)
# Cell_sub2 = Cell_2 - Cell_1
# Cell_mul = Cell_1 * Cell_2
# Cell_div = Cell_2 / Cell_1
#
# print('Cell_1\t', Cell_1)
# print('Cell_2\t', Cell_2)
# print('add\t\t', Cell_add)
# print('sub1\t', Cell_sub1)
# print('sub2\t', Cell_sub2)
# print('mul\t\t', Cell_mul)
# print('div\t\t', Cell_div)
#
# Cell_3 = Cell(20)
# make_order_1 = Cell_3.make_order(6)
# print(f'\nРеализация make_order\n{make_order_1}')